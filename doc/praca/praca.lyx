#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass aghdpl
\begin_preamble
% \documentclass{aghdpl}               % przy kompilacji programem latex
% \documentclass[pdflatex,en]{aghdpl}  % praca w języku angielskim
% dodatkowe pakiety
\usepackage{enumerate}
\usepackage{listings}
\lstloadlanguages{TeX}
\usepackage{caption} 
\captionsetup[figure]{labelformat=simple, labelsep=period}
\captionsetup[table]{labelformat=simple, labelsep=period}
%\captionsetup{font=small}
\captionsetup{margin=10pt, font={small}, labelfont=bf, format=hang}
\usepackage{esint}
\clubpenalty = 10000
\widowpenalty = 10000
%\usepackage{graphicx}
%\usepackage{grfext}
%\AtBeginDocument{%
% \PrependGraphicsExtensions*{
%    .mps,.MPS,.pdf,.PDF,.eps,.EPS,.ps,.PS,
%    .png,.PNG,.jpg,.jpeg,.JPG,.JPEG,
%    .funny,.foobar
%  }%
%  \PrintGraphicsExtensions % see .log file
%}
% \usepackage[style=numeric-comp]{biblatex}
% \setlength{\itemsep}{-1\parsep}
%---------------------------------------------------------------------------
%\usepackage{epstopdf}
\usepackage{mciteplus}
\end_preamble
\options pdflatex
\use_default_options true
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman utopia
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics none
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\float_placement H
\paperfontsize 12
\spacing onehalf
\use_hyperref true
\pdf_title "Praca dyplomowa"
\pdf_author "Wojciech Gumuła"
\pdf_subject "Algorytm detekcji osi pojazdów"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indeks
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=tblr"
\tracking_changes false
\output_changes false
\html_math_output 3
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
author{Wojciech Gumuła}
\end_layout

\begin_layout Plain Layout


\backslash
shortauthor{W.
 Gumuła}
\end_layout

\begin_layout Plain Layout


\backslash
titlePL{Implementacja algorytmu detekcji osi pojazdów samochodowych w oparciu
 o profile R i X}
\end_layout

\begin_layout Plain Layout


\backslash
titleEN{Implementation of algorithm for vehicle axles detection based on
 R and X-profile}
\end_layout

\begin_layout Plain Layout


\backslash
shorttitle{Detekcja ilości osi pojazdów}
\end_layout

\begin_layout Plain Layout


\backslash
faculty{Wydział Elektrotechniki, Automatyki,
\backslash

\backslash
Informatyki i Inżynierii Biomedycznej}
\end_layout

\begin_layout Plain Layout


\backslash
division{}
\end_layout

\begin_layout Plain Layout


\backslash
specialization{Automatyka i Robotyka}
\end_layout

\begin_layout Plain Layout


\backslash
thesistype{Praca dyplomowa inżynierska}
\end_layout

\begin_layout Plain Layout


\backslash
supervisor{dr inż.
 Zbigniew Marszałek}
\end_layout

\begin_layout Plain Layout


\backslash
acknowledgements{Wymaga odkomentowania linijek w aghdpl.cls} 
\end_layout

\begin_layout Plain Layout

%
\backslash
date{2015} 
\end_layout

\begin_layout Plain Layout


\backslash
titlepages
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{tocdepth}{1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Teoria
\end_layout

\begin_layout Chapter
Wstęp
\end_layout

\begin_layout Standard
Analiza parametrów pojazdów i klasyfikacja na ich bazie stanowi zagadnienie
 często poruszane w pracach naukowych, których autorzy starają się wykorzystać
 informacje statystyczne na temat ruchu samochodowego.
\end_layout

\begin_layout Standard
Na podstawie danych o liczbie przejeżdżających drogą pojazdów może być ustalony
 poziom eksploatacji połączenia i w związku z tym zaplanowane mogą być możliwośc
i rozbudowy infrastruktury w najlepszym kierunku.
 
\end_layout

\begin_layout Standard
Informację na temat parametrów pojazdu również może być
\begin_inset space ~
\end_inset

wykorzystana do wielu celów.
 Znając przybliżone wymiary pojazdu można zaprojektować system informacyjny,
 który ostrzegałby kierowców w sytuacji, gdy pojazd może mieć problemy z
 pokonaniem odcinka drogi - na przykład ze względu na znajdujący się na
 trasie niski wiadukt czy zwężenie jezdni.
 Informacja o prędkości pojazdu może być użyta w trakcie projektowania systemu
 ostrzegającego przed przekroczeniem dopuszczalnej prędkości.
 Często stosowane są również czujniki określające wagę pojazdów, zazwyczaj
 przez służby odpowiedzialne za kontrole drogowe.
 
\end_layout

\begin_layout Standard
Znajomość danych na temat liczby osi pojazdu i ich położenia również jest
 użyteczna - pozwala na klasyfikację pojazdu na podstawie schematów FHWA
 
\begin_inset CommandInset citation
LatexCommand cite
key "fhwaclasses"

\end_inset

, wyróżniającego 13 kategorii, ALTernative vehicle classification, która
 wyróżnia 20 kategorii, lub dowolnej innej, zaprojektowanej by jak najlepiej
 kategoryzować badane zagadnienie.
 Klasyfikację pojazdu można wykorzystać w celu automatyzacji systemu przydzielan
ia opłat na płatnych odcinkach dróg lub do analizy wykorzystania drogi przez
 pojazdy różnych kategorii - dane takie mogą posłużyć w przyszłości do jak
 najlepszego rozwoju infrastruktury, stanowią bardziej użyteczną informację,
 niż dane wyłącznie o liczbie przejeżdżających pojazdów.
\end_layout

\begin_layout Standard
Często nie jest potrzebna żadna informacja na temat pojazdu ponad sam fakt
 wykrycia go.
 Przykładem systemu wykorzystującego dane na temat obecności pojazdów są
 systemy sterowania sygnalizacją świetlną na wielu skrzyżowaniach.
 W ich przypadku nie są istotne parametry poszczególnych pojazdów, choć
 przydatna może być informacja na temat natężenia ruchu w poszczególnych
 kierunkach, co pozwala na optymalizację płynności ruchu.
\end_layout

\begin_layout Standard
Ze względu na liczbę możliwych zastosowań, zachęcające staje się zagadnienie
 projektowania jak najbardziej dokładnych czujników i algorytmów przetwarzania
 danych, które jednocześnie zachowują przystępną cenę i gwarantują dużą
 wydajność.
\end_layout

\begin_layout Section*
Cel i zakres pracy
\end_layout

\begin_layout Standard
Zadanie wykrywania osi pojazdów samochodowych w ruchu drogowym wykonuje
 się przy użyciu czujników różnego typu.
 Wykorzystuje się piezoelektryczne czujniki nacisku, czujniki kwarcowe i
 inne.
 Podejmowane są również próby klasyfikacji pojazdów metodami wizyjnymi.
 Na Katedrze Metrologii i Elektroniki AGH zaprojektowany został system wyznaczan
ia parametrów pojazdów przy użyciu czujników indukcyjnych
\begin_inset CommandInset citation
LatexCommand cite
key "Gajd2012"

\end_inset

.
 Cechują się one dużą trwałością, niską ceną i niedużym skomplikowaniem
 instalacji, umożliwiający przy tym wyznaczanie szeregu parametrów pojazdu.
 Zaprojektowany algorytm pozwala, na bazie odczytów z czujników, na klasyfikację
 liczby osi pojazdu z dużą dokładnością, rzędu ponad 95% w większości przypadków
 
\begin_inset CommandInset citation
LatexCommand cite
key "marszalek2013"

\end_inset

.
 
\end_layout

\begin_layout Standard
Praca podejmuje temat wykorzystania możliwości języka programowania C 
\begin_inset CommandInset citation
LatexCommand cite
key "cman"

\end_inset

 i środowiska Linux 
\begin_inset CommandInset citation
LatexCommand cite
key "linuxwww"

\end_inset

 do budowy programu implementującego algorytm wykrywania osi.
 Założenia projektowe języka C - duża wydajność, umożliwienie operacji wejścia-w
yjścia na niskim poziomie, metody zarządzania pamięcią - pozwalają na zaprojekto
wanie bardzo wydajnych narzędzi.
 Natomiast dzięki użycia systemu Linux, skorzystać można z jego przydatnych
 funkcji, jak potoki 
\begin_inset CommandInset citation
LatexCommand cite
key "linuxpipes"

\end_inset

 umożliwiające kolejkowanie programów w celu zbudowania pełnoprawnej aplikacji
 czy obsługa sygnałów i kodów błędów
\begin_inset CommandInset citation
LatexCommand cite
key "linuxsignals"

\end_inset

, ułatwiająca projektowanie oprogramowania.
\end_layout

\begin_layout Standard
W pracy podjęto zadanie implementacji algorytmu detekcji liczby osi pojazdu
 oraz rozbudowę funkcji programu o możliwość wyznaczania przybliżonej długości
 pojazdu oraz odległości pomiędzy osiami.
 Ponadto, zaimplementowano zbiór narzędzi umożliwiających użycie programu
 do wyznaczania parametrów w trybie ciągłym, bez konieczności interakcji
 ze strony użytkownika, oraz prosty model graficznego interfejsu użytkownika,
 wyświetlającego wyjście programu.
 Przy użyciu języka Python 
\begin_inset CommandInset citation
LatexCommand cite
key "pythonman"

\end_inset

 zaprojektowano narzędzie do wygodnego testowania poprawności działania
 programu dla dużego zbioru danych, przeprowadzono testy działania programu
 oraz porównano wyniki i wydajność z wersją algorytmu zaimplementowaną w
 programie Matlab.
\end_layout

\begin_layout Standard
Główne założenia przyjęte w trakcie projektowania programu obejmowały dużą
 szybkość działania, bezwzględną poprawność implementacji - szczelne zarządzanie
 zasobami pamięci, uniknięcie ostrzeżeń w trakcie kompilacji, obsługę strumieni
 wejścia/wyjścia i zgodność ze standardem POSIX i ideą GNU 
\begin_inset CommandInset citation
LatexCommand cite
key "gnustandard"

\end_inset

.
\end_layout

\begin_layout Chapter
Pomiary parametrów pojazdów samochodowych przy użyciu pętli indukcyjnych
\end_layout

\begin_layout Standard
W celu badania parametrów pojazdów samochodowych można wykorzystać zasadę
 działania cewki indukcyjnej w interakcji z przemieszczającymi się w jej
 otoczeniu przedmiotami o powierzchniach z różnych materiałów.
 By wykorzystać to zjawisko, projektowane są układy pomiarowe składające
 się z szeregu czujników indukcyjnych pętlowych, układu kondycjonowania
 sygnału oraz układu elektronicznego odpowiedzialnego za rejestrację sygnałów
 w celu dalszej ich interpretacji.
\end_layout

\begin_layout Standard
Czujnik indukcyjny pętlowy zbudowany jest ze zwojów izolowanego przewodu,
 który zazwyczaj umieszcza się pod nawierzchnią jezdni.
 Wykorzystuje się różne kształty i wymiary czujników, w zależności od przyjętych
 wymagań.
 W celu badania parametrów pojazdów na katedrze Metrologii AGH wykorzystano
 serię czujników pętlowych o różnych długościach 
\begin_inset CommandInset citation
LatexCommand cite
key "Gajd2012"

\end_inset

.
 Dzięki wykorzystaniu czujników o innych kształtach, możliwe jest profilowanie
 stref czujności, a co za tym idzie, uzyskanie dokładniejszych pomiarów
 dla badanego zagadnienia.
 Wybór kształtu czujnika podyktowany jest rodzajem pomiarów - zbieranie
 informacji na temat parametrów pojazdu, sterowanie sygnalizacją świetlną,
 wyzwalanie pracy innych systemów w chwili aktywności czujnika.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/inductivedetector.png
	display false
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat pętlowego czujnika indukcyjnego o wymiarach 
\series bold
w
\series default
 x 
\series bold
p
\series default
 w poziomie oraz odległości 
\series bold
o
\series default
 pomiędzy zwojami.
 Źródło: 
\begin_inset CommandInset citation
LatexCommand cite
key "marszalek2013"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ind_sensor"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Układ kondycjonowania sygnału to moduł elektroniczny, który odpowiada za
 wstępną analizę sygnału.
 Stawia się przed nim zadanie szybkiej reakcji na pojawienie się pojazdu
 w otoczeniu czujnika.
 Jest to konieczne, by uzyskać dokładny pomiar.
 Na wyjściu układu, w zależności od jego typu, można uzyskać jeden sygnał
 - M
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

, lub dwa - R
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

 i X
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

.
 Sygnały R
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

 i X
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

 odpowiadają magnetycznym profilom rezystancji i reaktancji.
 Sygnał M
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

 opisuje natomiast pewną funkcję profili R
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

 i X
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

 (może być to pierwiastek z sumy profili z pewnymi współczynnikami).
 Znając tylko sygnał M
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

, niemożliwe jest uzyskanie sygnałów magnetycznych profili rezystancji i
 reaktancji, co może znacznie ograniczyć możliwości zastosowania układów
 kondycjonowania sygnału tego typu do badania parametrów pojazdu.
\end_layout

\begin_layout Standard
Ostatnim elementem układu pomiarowego może być mikroprocesor lub komputer,
 odpowiedzialny za zbieranie danych i ich dalszą analizę.
 Można zastosować w tym celu moduł odpowiedzialny za przesyłanie zebranych
 danych do bazy, by umożliwić ich dalszą obróbkę (na przykład gdy zbierane
 są dane, które mają być wykorzystane w pracy naukowej).
 Inną metodą jest bezpośrednia analiza danych zaraz po ich uzyskaniu - może
 to znaleźć zastosowanie w systemie odpowiedzialnym za sterowanie sygnalizacją
 świetlną na skrzyżowaniu na podstawie natężenia ruchu pojazdów w różnych
 kierunkach.
\end_layout

\begin_layout Standard
Czujniki indukcyjne pętlowe mogą służyć do badania parametrów pojazdów samochodo
wych.
 Możliwe jest zliczanie ilości przejeżdżających przez czujnik pojazdów,
 pomiar prędkości i długości pojazdu, natężenia ruchu.
 Możliwe jest przy użyciu czujnika wykrywanie pojazdów spełniających zadane
 kryteria, na przykład tylko autobusów, czy pojazdów ciężarowych z przyczepą.
 W trakcie wykonywania niniejszej pracy, badana była możliwość wykrywania
 ilości osi pojazdu samochodowego oraz długości pojazdu i odległości pomiędzy
 poszczególnymi osiami.
\end_layout

\begin_layout Standard
Wykorzystanie tej metody badania parametrów pojazdu niesie za sobą zalety,
 które tłumaczą popularność tego typu narzędzi - są one tanie, a dzięki
 umieszczeniu pod nawierzchnią jezdni odporne na większość czynników atmosferycz
nych i kontakt fizyczny z podwoziem pojazdu.
 Ich montaż jest prosty, a układ pomiarowy nie wymaga zastosowania skomplikowany
ch elementów elektronicznych.
 Ponadto, wykorzystując dobrze zaprojektowany algorytm analizujący dane
 pomiarowe, możliwe jest uzyskanie informacji na temat licznych parametrów
 pojazdu.
 
\end_layout

\begin_layout Chapter
Założenia projektowe
\end_layout

\begin_layout Standard
Przed przystąpieniem do implementacji programu, przyjęte zostały pewne założenia
, opisujące sposób implementacji i cel projektu.
 Umożliwiło to określenie wymagań już na samym początku pracy i dzięki temu
 zwiększyło sprawność pracy.
 Podstawowym założeniem, przyjętym na samym początku pracy była decyzja
 o implementacji algorytmu z wykorzystaniem środowiska Linux.
 Kierowano się przy tym możliwościami oferowanymi przez ten system, które
 omówione są po części poniżej.
 Ponadto system ten cieszy się dużym wsparciem społeczności, dzięki czemu
 nietrudno znaleźć materiały opisujące jego funkcje.
 Zdecydowano się na przygotowanie oprogramowania w języku C, ze względu
 na oferowane przez to narzędzie wydajność i możliwość kontroli nad zasobami.
\end_layout

\begin_layout Standard
Poniżej przedstawiono pozostałe główne założenia projektu i ograniczenia
 przyjęte w trakcie realizacji projektu.
\end_layout

\begin_layout Section
Przyjęte założenia
\end_layout

\begin_layout Subsection
Praca zgodnie z ideą oprogramowania GNU i standardem POSIX
\end_layout

\begin_layout Standard
W trakcie pracy inspirowano się programami powstającymi wokół ruchu GNU
 
\begin_inset CommandInset citation
LatexCommand cite
key "gnupage"

\end_inset

.
 W przeciągu wielu lat, gdy publikowane było oprogramowanie związane z nim,
 udało się przyjąć pewne założenia programowania, zwane GNU Coding Standards
 
\begin_inset CommandInset citation
LatexCommand cite
key "gnustandard"

\end_inset

.
 Opisują one zagadnienia, które często pojawiają się w trakcie pracy nad
 projektami programistycznymi, takie jak styl formatowania kodu, obsługiwane
 flagi czy sposób pisania komentarzy.
 
\end_layout

\begin_layout Standard
System Linux implementuje większość elementów wchodzących w skład standardu
 POSIX 
\begin_inset CommandInset citation
LatexCommand cite
key "posixstd"

\end_inset

, dzięki zastosowaniu się do reguł opisywanych w standardzie w trakcie pracy
 nad projektem, udało się uzyskać pewną formę przenośności - główny moduł
 programu powinien działać na wszystkich systemach, które implementują ten
 standard.
\end_layout

\begin_layout Standard
W trakcie pisania kodu programu, starano się stosować do Google C++ Style
 Guide - szeregu reguł opisujących sposób formatowania kodu w taki sposób,
 aby zwiększyć jego przejrzystość i czytelność 
\begin_inset CommandInset citation
LatexCommand cite
key "googlestyleguide"

\end_inset

.
 Pozwala to na utrzymanie podobnego stylu dla całego kodu źródłowego programu,
 a dzięki zwiększeniu czytelności wyszukiwanie błędów działania i rozwój
 programu staje się łatwiejszy.
\end_layout

\begin_layout Subsection
Podział na moduły
\end_layout

\begin_layout Standard
Zdecydowano się podzielić program na mniejsze elementy, moduły, z których
 każdy odpowiedzialny był za wyłącznie jedną funkcjonalność.
 Dzięki temu, kod źródłowy stał się bardziej zwięzły a programy bardziej
 przenośne.
\end_layout

\begin_layout Standard
Wyszczególniono kilka głównych funkcji pakietu
\end_layout

\begin_layout Itemize
moduł algorytmu - odpowiedzialny za główną funkcjonalność, czyli wyznaczanie
 liczby osi pojazdu i ich położeń
\end_layout

\begin_layout Itemize
moduł obserwatora - odpowiedzialny za śledzenie zmian w zadanych ścieżkach
 w oczekiwaniu na nowe pliki, które następnie mogą zostać wysłane do modułu
 algorytmu
\end_layout

\begin_layout Itemize
moduł graficzny - umożliwiający przedstawienie wyników pracy algorytmu poprzez
 interfejs 
\end_layout

\begin_layout Subsection
Potoki
\end_layout

\begin_layout Standard
Połączenia pomiędzy poszczególnymi modułami zostały zaimplementowane przy
 użyciu potoków dostępnych w systemie Linux 
\begin_inset CommandInset citation
LatexCommand cite
key "linuxpipes"

\end_inset

.
 Pozwalają one na łączenie dwóch programów w taki sposób, by wyjście jednego
 programu wysłane zostało na wejście drugiego.
 Jest to funkcja silnie wykorzystywana w trakcie pracy z systemem Linux.
 Można je wykorzystać na przykład w celu znalezienia wszystkich dokumentów
 tekstowych w danym katalogu i utworzenia archiwum je zawierającego, jak
 na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:pipes-example"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

find dokumenty | grep '.doc' | tar cfz archiwum.tar -T -
\begin_inset Caption Standard

\begin_layout Plain Layout
Przykład użycia potoków
\begin_inset CommandInset label
LatexCommand label
name "lis:pipes-example"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Symbol 
\emph on
|
\emph default
 oznacza potok łączący dwa sąsiednie programy, przy czym przepływ danych
 następuje od lewej do prawej, a więc wyjście programu 
\shape italic
ls
\shape default
 kierowane jest na wejście programu 
\shape italic
grep
\shape default
.
\end_layout

\begin_layout Subsection
Obsługa flag
\end_layout

\begin_layout Standard
Projektowany program miał być wywoływany z poziomu konsoli sytemu Linux,
 której wygląda podobnie do przedstawionej na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:linux-console"

\end_inset

.
 W celu umożliwienia interakcji z programem wywoływanym w ten sposób, zaimplemen
towano obsługę szeregu flag 
\begin_inset CommandInset citation
LatexCommand cite
key "gnucli"

\end_inset

.
 Dzięki temu już w momencie uruchomienia programu wykonywana jest pełna
 konfiguracja i nie jest konieczna dalsza interakcja użytkownika w trakcie
 pracy.
 Umożliwia to wykorzystanie programu w skryptach, na przykład w celu uruchomieni
a go na serwerze by wyznaczyć dane zebrane dla tysiąca pojazdów poprzez
 jedno wywołanie.
 
\end_layout

\begin_layout Standard
Zaimplementowano flagi odpowiedzialne za tryb pracy algorytmu, umożliwiające
 wyznaczenie danych na temat położenia osi i długości pojazdu, włączające
 weryfikację wyników z czujników piezo, zarządzające ilością informacji
 wyświetlanych na ekranie w trakcie pracy czy przekierowujące wyjście do
 pliku.
 Ponadto, zachowano zgodność ze standardem GNU, który zaleca implementację
 obsługi flag 
\shape italic
--version
\shape default
 i
\shape italic
 --help
\shape default
, wyświetlających odpowiednio informację o wersji programu i stronę pomocy.
\end_layout

\begin_layout Standard
Dokładny opis obsługiwanych flag przedstawiono w rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flags"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/terminal.eps
	display false

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Konsola systemowa.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:linux-console"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wydajność
\end_layout

\begin_layout Standard
Analiza zebranych wyników często wymaga przetworzenia danych dla setek czy
 tysięcy pojazdów.
 Z tego względu przed programem stawiane są silne wymagania dotyczące wydajności.
 Dzięki wykorzystaniu języka C do implementacji modułu odpowiedzialnego
 za obliczenia, możliwa była duża kontrola nad takimi elementami jak operacje
 wejścia-wyjścia i zarządzanie pamięcią, możliwa była duża optymalizacja
 czasu pracy programu dla jednego zestawu danych.
 Dokładna analiza tego zagadnienia przedstawiona została w rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:efficiency"

\end_inset

.
\end_layout

\begin_layout Subsection
Wielofunkcyjność
\end_layout

\begin_layout Standard
Program może być wywoływany na dwa sposoby.
 
\end_layout

\begin_layout Standard
Pierwszy umożliwia jednorazową analizę jednego lub wielu plików, które są
 kompletne w momencie uruchomienia programu.
 Może to być przydatne w sytuacji, gdy konieczne jest przeprowadzenie analizy
 zebranych wcześniej danych.
\end_layout

\begin_layout Standard
Program może również zostać wywołany w trybie oczekiwania na dane.
 W momencie, gdy pojawia się nowy plik z danymi, są one natychmiast analizowane.
 Jest to przydatne, gdy program działa bezpośrednio na systemie odpowiedzialnym
 za zbieranie danych - praktyczne wydaje się zaprojektowanie ciągu operacji,
 w którym dane odczytane trafiają do określonego folderu, są analizowane
 przez przygotowany program, a następnie prezentowane w czytelnej formie,
 na przykład poprzez stronę internetową.
 Pozwalałoby to na nadzorowanie pracy czujnika i zbieranie wyników bez konieczno
ści fizycznego kontaktu z urządzeniem.
\end_layout

\begin_layout Subsection
Stabilność pracy 
\end_layout

\begin_layout Standard
Ze względu na możliwość użycia programu w trybie ciągłym i analizy tysięcy
 zestawów danych w trakcie jednego uruchomienia programu, konieczne było
 zagwarantowanie stabilnej pracy programu w normalnych warunkach.
 W tym celu przyjęto założenie unikania jakichkolwiek niezdefiniowanych
 zachowań języka C, opisywanych w standardzie 
\begin_inset CommandInset citation
LatexCommand cite
key "cstandard"

\end_inset

 oraz rozwiązywania wszystkich ostrzeżeń przekazywanych przez kompilator
 języka.
 Ponadto, zadbano o zarządzanie pamięcią w taki sposób, by uniknąć wycieków
 pamięci.
 Dokładniejsza analiza tego zagadnienia znajduje się w rozdziale 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:stability"

\end_inset

.
\end_layout

\begin_layout Section
Przyjęte ograniczenia
\end_layout

\begin_layout Standard
Jednocześnie do przyjmowania założeń projektowych, przyjęte zostały również
 ograniczenia, opisujące pracę programu.
\end_layout

\begin_layout Itemize
Program nie jest odpowiedzialny za wstępną analizę sygnałów czujnika w celu
 wykrycia pojazdu.
 Przyjęto założenie, że próbka została już wstępnie przeanalizowana w celu
 odseparowania danych dotyczących krótkiego okresu, gdy pojazd znajdował
 się w otoczeniu czujnika.
\end_layout

\begin_layout Itemize
Jedna próbka danych powinna zawierać informacje dotyczące wyłącznie jednego
 pojazdu.
 W przypadku, gdy w jednym pliku danych pojawią się informacje dotyczące
 wielu pojazdów, zostaną one błędnie zinterpretowane.
\end_layout

\begin_layout Itemize
Próbka danych powinna mieć stosunkowo niewielką długość.
 Powinna zwierać wszystkie użyteczne informacje, a jednocześnie unikać przechowy
wania informacji nieistotnych.
 Zwiększenie rozmiaru próbki wpłynie liniowo
\begin_inset Marginal
status open

\begin_layout Plain Layout
liniowo?
\end_layout

\end_inset

 na czas pracy algorytmu.
 Nie przyjęto jednak żadnej konkretnej długości próbki, ani limitów długości
 - program powinien zachowywać się poprawnie dla danych o dowolnej długości,
 ograniczeniem może być jedynie ilość dostępnej pamięci i czasu pracy procesora.
\end_layout

\begin_layout Itemize
W trakcie projektowania programu, dostosowano go do pracy z konkretnym zestawem
 czujników.
 Praca z innymi czujnikami wymagałaby zmian w kodzie programu, a w przypadku,
 gdy czujniki posiadałyby inne parametry - również w kodzie algorytmu.
\end_layout

\begin_layout Itemize
Algorytm wykrywa poprawnie pojazdy o liczbie osi od dwóch do pięciu.
 W przypadku wykrycia sześciu lub więcej osi, dana próbka uznana zostanie
 za błędną.
\end_layout

\begin_layout Section*
Podsumowanie
\end_layout

\begin_layout Standard
Dostosowanie się do założeń przyjętych przed rozpoczęciem pracy powinno
 umożliwić większą kontrolę nad powstającym oprogramowaniem.
 Dzięki przyjęciu, że implementacja będzie pracować pod konkretnym systemem,
 od początku dostępne były narzędzia oferowane przez środowisko.
 Odbyło się to kosztem przenośności programów, których wykorzystanie na
 innych systemach, w tym tych z rodziny Windows byłoby czasochłonne i mniej
 wygodne.
 Wybór języka C również przyniosło pozytywne skutki - poza opisywanymi wcześniej
 cechami języka, które wykorzystano, przydatne okazały się również silne
 związki pomiędzy tym językiem a jądrem systemu Linux.
 Ten kluczowy składnik systemu w ponad 95% zaimplementowany jest w C 
\begin_inset CommandInset citation
LatexCommand cite
key "githublinux"

\end_inset

, dzięki czemu korzystanie z oferowanych interfejsów jest stosunkowo łatwe,
 gdy używa się tego samego języka.
 Dzięki podjęciu tych decyzji, możliwe stało się wykorzystanie przydatnych
 funkcjonalności systemu - potoki, strumienie, obsługa flag, oraz języka
 C - implementacja sygnałów systemowych czy obsługa błędów.
\end_layout

\begin_layout Part
Implementacja algorytmu
\end_layout

\begin_layout Chapter
Interfejs wejścia-wyjścia programu
\end_layout

\begin_layout Standard
Przed uruchomieniem programu, konieczne jest zebranie danych z czujników,
 zawierających informacje dla jednego pojazdu.
 Z tego względu konieczna była implementacja programu w taki sposób, by
 zintegrować go z systemem odpowiedzialnym za zbieranie odczytów.
 
\end_layout

\begin_layout Standard
Układ pomiarowy składa się z zestawu pięciu pętli indukcyjnych o rożnych
 parametrach oraz dwóch czujników piezoelektrycznych ułożonych wzdłuż pasa
 ruchu.
 Układ zbiera informacje w formie pary wartości sygnałów R
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

 i X
\begin_inset script subscript

\begin_layout Plain Layout
~
\end_layout

\end_inset

 dla każdej pętli oraz sygnały P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 i P
\begin_inset script subscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

 dla czujników piezo.
\end_layout

\begin_layout Standard
Przyjęto założenie, że system ten dostarcza dane w następujący sposób.
\end_layout

\begin_layout Itemize
Dane dostarczane są w formie tekstowej poprzez strumień wejściowy lub plik.
\end_layout

\begin_layout Itemize
Każdy wiersz zawiera próbkę danych dla jednej chwili czasowej w formacie
 trzynastu liczb.
 Pierwsza liczba oznacza czas odczytu próbki w sekundach, a pozostałe dwanaście
 opisuje sześć par sygnałów.
 
\end_layout

\begin_layout Itemize
Symbolem dziesiętnym jest znak kropki 
\begin_inset Quotes pld
\end_inset

.
\begin_inset Quotes prd
\end_inset

, a liczba ujemna opisywana jest przez znak myślnika 
\begin_inset Quotes pld
\end_inset

-
\begin_inset Quotes prd
\end_inset

 bez odstępu, na przykład: -2.4321.
\end_layout

\begin_layout Itemize
Dane są uporządkowane względem czasu, a więc każda kolejna próbka wystąpiła
 po poprzedniej - jest to wykorzystywane w przypadku przekazywania danych
 wielu pojazdów poprzez standardowy strumień wejścia.
\end_layout

\begin_layout Standard
Przykładowy fragment pliku wejściowego spełniający te założenia przedstawiono
 na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:input-data"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},tabsize=2"
inline false
status open

\begin_layout Plain Layout

0.023	0.16	-0.08	0.12	-0.06	0.07	-0.01	0.09	-0.17	0.11	0.38	0.02	0.03
\end_layout

\begin_layout Plain Layout

0.024	0.18	-0.06	0.12	-0.08	0.10	 0.02	0.09	-0.21	0.14	0.44	0.02	0.00
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Fragment pliku danych wejściowych
\begin_inset CommandInset label
LatexCommand label
name "lis:input-data"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kolejność danych to:
\end_layout

\begin_layout Itemize
czas w sekundach
\end_layout

\begin_layout Itemize
pętla 3m (2sygnały: X i R)
\end_layout

\begin_layout Itemize
pętla 1m (2sygnały: X i R)
\end_layout

\begin_layout Itemize
pętla 0,5m (2sygnały: X i R)
\end_layout

\begin_layout Itemize
pętla 0,3m (2sygnały: X i R)
\end_layout

\begin_layout Itemize
pętla 0,1m (2sygnały: X i R)
\end_layout

\begin_layout Itemize
czujnik piezo 1
\end_layout

\begin_layout Itemize
czujnik piezo 2
\end_layout

\begin_layout Standard
Przyjęto również następującą konwencję formatu wyjścia programu.
\end_layout

\begin_layout Standard
Format w przypadku korzystania z podstawowej funkcji programu, a więc wykrywania
 liczby osi pojazdu, przyjmuje postać
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

źródło n
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gdzie 
\shape italic
źródło
\shape default
 to nazwa pliku który przekazany był jako argument programu, lub ciąg 
\begin_inset Quotes pld
\end_inset

stdin
\begin_inset Quotes prd
\end_inset

 w przypadku wykorzystania strumienia wejściowego, a 
\shape italic
n 
\shape default
to liczba osi pojazdu (z wyszczególnieniem ciągu 
\begin_inset Quotes pld
\end_inset

5up
\begin_inset Quotes prd
\end_inset

 oznaczającego wykrycie pojazdu pięcioosiowego, z podniesioną jedną osią).
\end_layout

\begin_layout Standard
W przypadku wywołania dodatkowych funkcji programu, wyjście ulega rozwinięciu
\end_layout

\begin_layout Itemize
Funkcja wyznaczania położeń osi pojazdu wyświetla na wyjściu dodatkowy ciąg
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

źródło n d l_1 ...
 l_n+1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gdzie 
\shape italic
d
\shape default
 oznacza długość pojazdu a wartości 
\shape italic
l
\begin_inset script subscript

\begin_layout Plain Layout

\shape italic
1
\end_layout

\end_inset


\shape default
 ...
 
\shape italic
l
\begin_inset script subscript

\begin_layout Plain Layout

\shape italic
n+1
\end_layout

\end_inset


\shape default
 oznaczają poszczególne odległości zgodnie z rysunkiem 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:schemat-dlugosci"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat odległości
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:schemat-dlugosci"

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Funkcja weryfikacji z czujnikami piezoelektrycznymi dodaje drugą linię wyjścia
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "frame=tblr"
inline false
status open

\begin_layout Plain Layout

źródło n
\end_layout

\begin_layout Plain Layout

piezo N
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gdzie 
\shape italic
N
\shape default
 to liczba osi wyznaczona poprzez czujniki piezoelektryczne.
\end_layout

\end_deeper
\begin_layout Itemize
W przypadku wywołania jednocześnie funkcji wyznaczania położeń osi oraz
 weryfikacji na postawie czujników piezoelektrycznych, wyjście przyjmuje
 postać
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

źródło n d l_1 ...
 l_n+1
\end_layout

\begin_layout Plain Layout

piezo N L_1 ...
 L_n-1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gdzie wartości 
\shape italic
L
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset


\shape default
 ...
 
\shape italic
L
\begin_inset script subscript

\begin_layout Plain Layout
n-1
\end_layout

\end_inset


\shape default
 oznaczają odległości pomiędzy osiami zgodnie z rysunkiem 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:schemat-dlugosci"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Ilość informacji na wyjściu może zmienić się na żądanie użytkownika - możliwe
 jest wytłumienie wszelkich komunikatów, bądź wyświetlenie informacji na
 temat przeprowadzanych obliczeń.
\end_layout

\begin_layout Chapter
Algorytm detekcji liczby osi pojazdu
\end_layout

\begin_layout Standard
Algorytm detekcji liczby osi pojazdu stanowi podstawową funkcjonalność aplikacji
, wokół której budowane były pozostałe funkcje.
 Implementacja algorytmu miała spełniać założenia projektu
\end_layout

\begin_layout Itemize
wydajność
\end_layout

\begin_layout Itemize
stabilność
\end_layout

\begin_layout Itemize
poprawność działania, kompatybilność z implementacją bazową 
\begin_inset Marginal
status open

\begin_layout Plain Layout
??
\end_layout

\end_inset


\end_layout

\begin_layout Standard
W związku z tym, przygotowywana implementacja musiała być wykonana uważnie
 i starannie.
 Dzięki temu, udało się uzyskać algorytm równie dokładny, jak wersja bazowa,
 oferujący jednak wygodniejszy interfejs pracy i większą wydajność.
\end_layout

\begin_layout Standard
Algorytm składa się szeregu akcji, wywoływanych po załadowaniu pliku z danymi.
 Przedstawiono je poniżej, wraz z nazwami funkcji odpowiedzialnych za akcję.
\end_layout

\begin_layout Itemize
Usunięcie offsetu z sygnału.
 
\shape italic
remove_offset 
\begin_inset CommandInset label
LatexCommand label
name "alg-remove-offset"

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Na podstawie pierwszych trzydziestu próbek wyznaczana jest wartość przesunięcia
 względem zera dla każdego z dwunastu sygnałów.
 Wartości przesunięć są następnie odejmowane od odpowiednich wartości w
 każdej próbce, by przesunąć sygnał względem zera.
\end_layout

\end_deeper
\begin_layout Itemize
Wyznaczenie prędkości pojazdu.
 
\shape italic
find_velocity_distance
\end_layout

\begin_deeper
\begin_layout Standard
Na podstawie czujników piezoelektrycznych wyznaczana jest prędkość pojazdu
 w metrach na sekundę.
 Wartość ta jest wykorzystywana w kolejnym punkcie algorytmu.
\end_layout

\end_deeper
\begin_layout Itemize
Przycięcie danych do okna
\shape italic
.
 trim_data
\end_layout

\begin_deeper
\begin_layout Standard
Ciąg danych dla poszczególnych czujników przycinany jest do okresu, w którym
 w otoczeniu pętli indukcyjnej znajdował się badany pojazd.
 Pozwala to na zmniejszenie nakładu obliczeń wymaganych w dalszej części
 algorytmu.
\end_layout

\end_deeper
\begin_layout Itemize
Przycięcie danych do okna
\shape italic
.
 trim_to_window
\end_layout

\begin_deeper
\begin_layout Standard
Następuje kolejne zmniejszenie okna opisującego użyteczne dane.
 W tym celu wykorzystywane są własności transformaty Fouriera 
\begin_inset CommandInset citation
LatexCommand cite
key "Zielinski2002,Lyons2010"

\end_inset

.
\end_layout

\begin_layout Standard
Generowana jest transformata Fouriera dla funkcji F pary sygnałów pętli
 3m.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
F(X_{\sim},R_{\sim})=\sqrt{X_{\sim}^{2}+R_{\sim}^{2}}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
W tym celu wykorzystany został algorytm wyznaczania szybkiej transformaty
 Fouriera FFT 
\begin_inset CommandInset citation
LatexCommand cite
key "Rockmore1999"

\end_inset

.
 Posłużono się implementacją oferowaną przez bibliotekę 
\shape italic
kissfft 
\begin_inset CommandInset citation
LatexCommand cite
key "kissfft"

\end_inset

 - 
\shape default
poprawna implementacja algorytmu FFT wymaga dużego nakładu czasu, ponadto
 biblioteka spełnia wszystkie wymagania projektu, jest lekka, nie wymaga
 wielu zasobów, a przy tym generuje transformatę z dużą wydajnością.
\end_layout

\begin_layout Standard
Wygenerowany przebieg transformaty w dziedzinie częstotliwości ograniczany
 jest następnie do pierwszych 30 próbek i poddawany przekształceniu odwrotnemu,
 by uzyskać ponownie sygnał w dziedzinie czasu.
 Pozwala to w teorii na pozbycie się zakłóceń o wysokich częstotliwościach.
\end_layout

\begin_layout Standard
Uzyskany sygnał poddawany jest operacji usunięcia offsetu, analogicznie
 do metody 
\shape italic
remove_offset.
 
\shape default
Ostatnim krokiem jest określenie położenia okna, w tym celu zastosowano
 prostą implementację komparatora z histerezą 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:komparator-histereza"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=4,keywordstyle={\color{blue}},commentstyle={\color{green}\itshape},emphstyle={\color{red}},stringstyle={\color{red}},identifierstyle={\color{magenta}}"
inline false
status open

\begin_layout Plain Layout

const double l_bound = 0.5; // próg dolny
\end_layout

\begin_layout Plain Layout

const double u_bound = 0.8; // próg górny
\end_layout

\begin_layout Plain Layout

for (unsigned i = 0; i < length; i++) {
\end_layout

\begin_layout Plain Layout

	if (signal[i] > u_bound && in_window == false) {
\end_layout

\begin_layout Plain Layout

		in_window = true;
\end_layout

\begin_layout Plain Layout

		w_start = i;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else if (signal[i] < l_bound && in_window == true) {
\end_layout

\begin_layout Plain Layout

		w_end = i;
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementacja komparatora z histerezą.
\begin_inset CommandInset label
LatexCommand label
name "lis:komparator-histereza"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Przebiegi wszystkich sygnałów są następnie ograniczane do przedziału próbek
 [
\shape italic
w_start
\shape default
, 
\shape italic
w_end
\shape default
].
 
\end_layout

\end_deeper
\begin_layout Standard
Wykonanie tych operacji kończy etap wstępnego przetwarzania sygnału i pozwala
 na uruchomienie właściwej części algorytmu.
 Składają się to poniższe kroki.
\end_layout

\begin_layout Itemize
wyznaczenie sygnałów 
\shape italic
R, X, M
\shape default
 oraz wartości parametrów 
\shape italic
L
\begin_inset script subscript

\begin_layout Plain Layout
x
\end_layout

\end_inset


\shape default
 i
\shape italic
 L
\begin_inset script subscript

\begin_layout Plain Layout
m
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Wyznaczane są sygnały 
\shape italic
R 
\shape default
i 
\shape italic
X,
\shape default
 odpowiadające parze sygnałów dla pętli 0,1m, oraz sygnał
\shape italic
 M
\shape default
, opisany funkcją
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
M(X,R)=X^{2}+R^{2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Następnie wyznaczane są wartości 
\shape italic
L
\begin_inset script subscript

\begin_layout Plain Layout
x
\end_layout

\end_inset


\shape default
 - liczba próbek sygnału 
\shape italic
X
\shape default
 o wartości większej od 0,1, oraz 
\shape italic
L
\begin_inset script subscript

\begin_layout Plain Layout
m
\end_layout

\end_inset


\shape default
 - liczba próbek sygnału 
\shape italic
M
\shape default
 o wartości większej od 0,5.
\end_layout

\end_deeper
\begin_layout Itemize
określenie wartości parametrów 
\shape italic
a/b, H i Y
\shape default
.
\end_layout

\begin_deeper
\begin_layout Standard
Na podstawie wartości parametrów 
\shape italic
L
\begin_inset script subscript

\begin_layout Plain Layout
x
\end_layout

\end_inset


\shape default
oraz
\shape italic
 L
\begin_inset script subscript

\begin_layout Plain Layout
m
\end_layout

\end_inset


\shape default
definiowane są wartości parametrów zgodnie z tabelą
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
warunek
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{L_{x}}{L_{m}}>0,1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{L_{x}}{L_{m}}\leq0,1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a/b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0,21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0,5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
H
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0,45
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0,5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Parametry te są następnie wykorzystywane w trakcie właściwego poszukiwania
 osi.
\end_layout

\end_deeper
\begin_layout Itemize
wyznaczenie sygnału 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout
p
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Kolejnym krokiem jest wyznaczenie sygnału 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout
p
\end_layout

\end_inset


\shape default
 zgodnie z formułą
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
K_{p}=a/b\cdot R+X
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Pomocniczo wyznacza się również wartość 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout
pmax
\end_layout

\end_inset

=max(K
\begin_inset script subscript

\begin_layout Plain Layout
p
\end_layout

\end_inset

)
\shape default
.
 Jeśli wartość 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout
pmax
\end_layout

\end_inset


\shape default
 jest większa od 3, wprowadza się modyfikacje do wartości parametrów algorytmu:
\end_layout

\begin_layout Standard

\shape italic
Y
\shape default
 = 0,8, 
\shape italic
H
\shape default
 = 0,45.
\end_layout

\begin_layout Standard
Dokonuje się również normalizacji sygnału 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout
p
\end_layout

\end_inset


\shape default
 na sygnał
\shape italic
 K
\begin_inset script subscript

\begin_layout Plain Layout
u
\end_layout

\end_inset


\shape default
o wartościach z przedziału 0-5.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,tabsize=4,keywordstyle={\color{blue}},commentstyle={\color{green}\itshape},emphstyle={\color{red}},stringstyle={\color{red}},identifierstyle={\color{magenta}}"
inline false
status open

\begin_layout Plain Layout

for (unsigned i = 0; i < length; i++)
\end_layout

\begin_layout Plain Layout

	Ku[i] = 5 * Kp[i] / Kp_max; 
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Normalizacja sygnału K
\shape italic
p
\shape default

\begin_inset CommandInset label
LatexCommand label
name "lis:kp-signal"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
wyszukiwanie osi
\end_layout

\begin_deeper
\begin_layout Standard
Mając sygnał 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout
u
\end_layout

\end_inset


\shape default
 oraz parametry 
\shape italic
a/b, H i Y
\shape default
 można przystąpić do procedury szukania osi.
 Odpowiada za nią poniższa funkcja 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:counter-fun"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,tabsize=4,keywordstyle={\color{blue}},commentstyle={\color{green}\itshape},emphstyle={\color{red}},stringstyle={\color{red}},identifierstyle={\color{magenta}}"
inline false
status open

\begin_layout Plain Layout

unsigned counter(double *Ku, unsigned len, double Y, double H,
\end_layout

\begin_layout Plain Layout

                 unsigned *axle_positions) {
\end_layout

\begin_layout Plain Layout

    if (Ku == NULL) {
\end_layout

\begin_layout Plain Layout

        exit(EINVAL);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    unsigned num_axles = 0;
\end_layout

\begin_layout Plain Layout

    unsigned is_high = 0; // flaga stanu
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    const double level_top = Y + H / 2;
\end_layout

\begin_layout Plain Layout

    const double level_bottom = Y - H / 2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    double val_max = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (unsigned i = 0; i < len; i++) {
\end_layout

\begin_layout Plain Layout

        if (is_high == 0 && Ku[i] >= level_top) {
\end_layout

\begin_layout Plain Layout

            is_high = 1;
\end_layout

\begin_layout Plain Layout

            num_axles++;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        else if (is_high == 1 && Ku[i] < level_bottom) {
\end_layout

\begin_layout Plain Layout

            is_high = 0;
\end_layout

\begin_layout Plain Layout

            val_max = 0;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if (axle_positions != NULL) {
\end_layout

\begin_layout Plain Layout

			if (is_high && val_max < Ku[i]) {
\end_layout

\begin_layout Plain Layout

                axle_positions[num_axles - 1] = i;
\end_layout

\begin_layout Plain Layout

                val_max = Ku[i];
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return num_axles;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Funkcja poszukująca osie.
\begin_inset CommandInset label
LatexCommand label
name "lis:counter-fun"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
W przypadku znalezienia dwóch, trzech lub pięciu osi, algorytm kończy działanie,
 zakładając, że wynik jest poprawny.
 
\end_layout

\end_deeper
\begin_layout Standard
Wprowadzono ponadto dwa dodatkowe warunki, które poprawiają skuteczność
 algorytmu.
\end_layout

\begin_layout Itemize
szukanie drugiej osi
\end_layout

\begin_deeper
\begin_layout Standard
Jeśli udało znaleźć się tylko jedną oś, modyfikuje się parametry i ponawia
 poszukiwania.
 Przyjmuje się wartość parametru 
\shape italic
H 
\shape default
= 0,1, natomiast wartość parametru 
\shape italic
Y
\shape default
 zmniejsza się każdorazowo o 0,1 i ponawia poszukiwania do czasu odnalezienia
 co najmniej dwóch osi lub osiągnięcia przez parametr
\shape italic
 Y 
\shape default
wartości nie większej niż 0,15.
 Wystąpienie dowolnego warunku kończy działanie algorytmu.
\end_layout

\end_deeper
\begin_layout Itemize
szukanie podniesionej piątej osi
\end_layout

\begin_deeper
\begin_layout Standard
Jeśli odnaleziono 4 osie, uruchamia się procedura poszukiwania podniesionej
 piątej osi.
 Zmiany sygnału w takiej sytuacji są niewielkie, stąd konieczność wprowadzenia
 modyfikacji do wartości parametru 
\shape italic
Y
\shape default
.
 Zmniejsza się go każdorazowo o 0,1 i ponawia poszukiwania do czasu, do
 póki wartość parametru 
\shape italic
Y
\shape default
 jest większa od 0,15 oraz odnaleziono wciąż 4 osie.
 W przypadku odnalezienia piątej osi, uznaje się ją za poszukiwaną oś podniesion
ą, natomiast w przypadku wykrycia wartości innej niż 4 lub 5 osi w dowolnym
 miejscu procedury, uznaje się to za błąd i przyjmuje wartość 4 osi za poprawny
 wynik algorytmu.
\end_layout

\end_deeper
\begin_layout Standard
Powyższe operacje stanowią kompletny algorytm poszukiwania osi pojazdu.
 W kolejnych rozdziałach przedstawiono modyfikacje algorytmu, które zwiększają
 jego funkcjonalność oraz umożliwiają weryfikację wyników.
\end_layout

\begin_layout Chapter
Weryfikacja przy użyciu czujników piezoelektrycznych
\end_layout

\begin_layout Standard
Stanowisko pomiarowe dysponuje dwoma czujnikami piezoelektrycznymi, które
 wykorzystywane są do określania prędkości pojazdu.
 Odczyty te mogą również posłużyć do określenia ilości osi przejeżdżającego
 pojazdu.
 Cecha ta została wykorzystana w programie w celu weryfikacji działania
 algorytmu.
\end_layout

\begin_layout Standard
O ile wykorzystanie danych z czujników piezoelektrycznych do określenia
 liczby osi jest znacznie łatwiejsze niż implementacja algorytmu przy użyciu
 pomiarów z czujników indukcyjnych, to z wykorzystaniem tego typu czujników
 wiążą się ograniczenia.
 Przede wszystkim, niemożliwe jest wykrycie podniesionej osi.
 Odczyt ogranicza się do możliwości wykrycia nacisku osi, a przez to ich
 liczby oraz prędkości pojazdu.
 Czujniki te są również bardziej narażone na obciążenia mechaniczne.
\end_layout

\begin_layout Standard
W celu weryfikacji posłużono się sygnałem z jednego czujnika - zakładając,
 że czujniki działają poprawnie, sygnał z obu powinien mieć przebieg różniący
 się wyłącznie fazą.
 Sygnał przetwarzany był przez funkcję zaprezentowaną na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:counter-fun"

\end_inset

, przy nastawach 
\shape italic
Y
\shape default
 = 2, 
\shape italic
H
\shape default
 = 0,1.
 Sygnał z czujników piezoelektrycznych powinien być zbliżony do sygnału
 binarnego 0-5 i pozbawiony drgać, wybór poziomu odniesienia w okolicy środka
 tego przedziału zapewnia więc dokładność odczytu.
\end_layout

\begin_layout Standard
Wyznaczenie liczby osi stanowi koniec pierwszej fazy testu.
 W przypadku, gdy nie jest ona równa liczbie wyznaczonej przez algorytm
 detekcji osi, program kończy działanie.
 W przeciwnym razie wyznaczany jest nowy sygnał, 
\shape italic
CP
\shape default
, który stanowi złożenie sygnału z piezo P
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 oraz sygnału K
\begin_inset script subscript

\begin_layout Plain Layout
u
\end_layout

\end_inset

 przetworzonego przez filtr dwupołożeniowy.
 Sposób obliczania wartości sygnału CP pokazano na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:cp-signal"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,tabsize=4,keywordstyle={\color{blue}},commentstyle={\color{green}\itshape},emphstyle={\color{red}},stringstyle={\color{red}},identifierstyle={\color{magenta}}"
inline false
status open

\begin_layout Plain Layout

for (unsigned i = 0; i < length; i++) {
\end_layout

\begin_layout Plain Layout

    if (is_high == 0 && Ku[i] >= level_top) {
\end_layout

\begin_layout Plain Layout

        is_high = 5;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else if (is_high == 5 && Ku[i] < level_bottom) {
\end_layout

\begin_layout Plain Layout

        is_high = 0;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    CP[i] = is_high + P1[i];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Generowanie sygnału CP.
\begin_inset CommandInset label
LatexCommand label
name "lis:cp-signal"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otrzymany sygnał CP przetwarzany jest ponownie przez funkcję z listingu
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:counter-fun"

\end_inset

 z parametrami 
\shape italic
Y
\shape default
 = 8, 
\shape italic
H
\shape default
 = 0.
 Wyjście funkcji stanowi liczbę osi wykrytych przez algorytm weryfikacji
 wyników.
\end_layout

\begin_layout Chapter
Detekcja długości pojazdu i położenia osi
\end_layout

\begin_layout Standard
Informacja na temat liczby osi pojazdu nie pozwala określić dokładnie klasy
 pojazdu.
 Dwie osie posiadają zarówno małe auta osobowe, jak i pojazdy ciężarowe.
 Z tego powodu, dane na temat osi można uzupełnić o długość pojazdu oraz
 o rozstaw poszczególnych osi.
 Taki zbiór danych umożliwia dokładniejsze określenie typu pojazdu, którego
 dotyczy próbka pomiarów.
\end_layout

\begin_layout Standard
W celu wyznaczenia przybliżonej długości pojazdu, zaimplementowano algorytm
 na bazie odczytów z czujników indukcyjnych.
\end_layout

\begin_layout Standard
Wyznaczono sygnał 
\shape italic
M
\shape default
 opisany funkcją
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
M(R_{1},X_{1})=R_{1}^{2}+X_{1}^{2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Gdzie R
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 i X
\begin_inset script subscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 stanowią wartości sygnałów dla pętli indukcyjnej 1m.
\end_layout

\begin_layout Standard
W większości przypadków, sygnał taki stanowi dobrą bazę do badania położenia
 pojazdu względem czujnika.
 Przebieg sygnału w czasie przedstawiono na wykresie 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:m-signal"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Przebieg badanego sygnału M.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:m-signal"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wykorzystując pokazaną na wykresie własność, można zaprojektować algorytm,
 który określi przybliżoną długość pojazdu.
 Algorytmem jest proste wyznaczenie przedziału, w którym wartości sygnału
 
\shape italic
M 
\shape default
przekraczają przyjęty próg odcięcia 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout
l
\end_layout

\end_inset


\shape default
.
 W trakcie pracy nad implementacją programową przyjęto wartość 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout
l
\end_layout

\end_inset


\shape default
 = 0,5.
 Implementację funkcji wyznaczającej okno, w którym znajduje się w przybliżeniu
 wykryte podwozie pojazdu zaprezentowano na listingu 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:veh-length"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,tabsize=4,keywordstyle={\color{blue}},commentstyle={\color{green}\itshape},emphstyle={\color{red}},stringstyle={\color{red}},identifierstyle={\color{magenta}}"
inline false
status open

\begin_layout Plain Layout

    for (unsigned i = 0; i < length; i++) {
\end_layout

\begin_layout Plain Layout

        if (M[i] > K_level) {
\end_layout

\begin_layout Plain Layout

            index_start = i;
\end_layout

\begin_layout Plain Layout

            break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    for (unsigned i = length - 1; i > 0; i--) {
\end_layout

\begin_layout Plain Layout

        if (M[i] > K_level) {
\end_layout

\begin_layout Plain Layout

            index_end = i;
\end_layout

\begin_layout Plain Layout

            break;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:veh-length"

\end_inset

Sposób określania okna przejazdu.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Znając długość okna
\shape italic
 l
\shape default
 opisanego zależnością
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
l=index_{end}-index_{start}\label{eq:roznica-indeksow}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
można, dzięki znajomości różnicy czasu pomiędzy dwoma próbkami 
\shape italic
dt
\shape default
 oraz prędkości pojazdu w metrach na sekundę 
\shape italic
v
\shape default
, wyznaczyć długość pojazdu 
\shape italic
L 
\shape default
w metrach
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
L=l\cdot v\cdot dt
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Wartość ta jest tylko przybliżeniem rzeczywistej długości pojazdu, może
 posłużyć jednak do wstępnej analizy rodzaju pojazdu.
\end_layout

\begin_layout Standard
Położenia poszczególnych osi wyznaczane są we wcześniejszej części algorytmu
 (w trakcie wyznaczania liczby osi pojazdu).
 Przyjmuje się, że środek osi znajduje się w punkcie, gdzie wartość sygnału
 
\shape italic
K
\begin_inset script subscript

\begin_layout Plain Layout

\shape italic
p
\end_layout

\end_inset


\shape default
[
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:kp-signal"

\end_inset

] osiąga lokalne maksimum.
 Znając indeks położenia osi 
\shape italic
p
\begin_inset script subscript

\begin_layout Plain Layout

\shape italic
i
\end_layout

\end_inset


\shape default
 oraz prędkość pojazdu 
\shape italic
v
\shape default
 i różnicę czasu pomiędzy kolejnymi próbkami 
\shape italic
dt
\shape default
, można wyznaczyć odległość osi od początku pojazdu, zgodnie z zależnością
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
P_{i}=p_{i}\cdot v\cdot dt\label{eq:polozenie-osi}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Wynik jest następnie weryfikowany - różnica wyznaczonej długości pojazdu
 oraz sumy odległości pierwszej osi od początku pojazdu, odległości pomiędzy
 poszczególnymi osiami oraz odległości ostatniej osi od końca pojazdu nie
 może być większa od przyjętego progu błędu 
\shape italic
e
\shape default
=0,02.
 W przypadku, gdy wynik spełnia warunek, uznawany jest za poprawny i algorytm
 kończy pracę.
 W przeciwnym razie, użytkownik może zostać poinformowany o błędzie.
\end_layout

\begin_layout Standard
Wartości położenia osi można zweryfikować również na podstawie odczytów
 z czujników piezoelektrycznych.
 Funkcja odpowiedzialna za to zadanie uruchamiania jest, gdy użytkownik
 zdefiniował odpowiednią flagę przy starcie programu.
\end_layout

\begin_layout Standard
Za indeks położenia osi przyjmuje się moment, w którym pojawi się narastające
 zbocze sygnału czujnika.
 Znając indeksy wszystkich osi, można wyznaczyć odległości pomiędzy kolejnymi
 osiami zgodnie z zależnościami 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:roznica-indeksow"

\end_inset

oraz 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:polozenie-osi"

\end_inset

.
\end_layout

\begin_layout Standard
Ze względu na uproszczenia przyjęte w algorytmie wyznaczającym odległości
 na bazie odczytów z czujników indukcyjnych, wartości uzyskane z piezo gwarantuj
ą zazwyczaj większą dokładność.
 Uznano jednak to zjawisko za dopuszczalne, ponieważ informacja na temat
 długości pojazdu ma pełnić jedynie pomocniczą rolę - z dużym prawdopodobieństwe
m można określić typ pojazdu, znając dokładną ilość osi oraz ich położenia
 i długość pojazdu z dokładnością do kilkunastu centymetrów.
\end_layout

\begin_layout Chapter
Analiza skuteczności algorytmu
\end_layout

\begin_layout Part
Omówienie programu
\end_layout

\begin_layout Chapter
Wymagania i instalacja
\end_layout

\begin_layout Standard
W trakcie implementacji programu przyjęto kilka założeń odnośnie środowiska
 użytkownika końcowego.
 Przede wszystkim, założono, że algorytm wykrywania osi uruchamiany będzie
 z poziomu systemu rodziny Unix 
\begin_inset CommandInset citation
LatexCommand cite
key "unix-page"

\end_inset

 bądź uniksopodobnego - na przykład Linux 
\begin_inset CommandInset citation
LatexCommand cite
key "linux-page"

\end_inset

.
 Przyjęto, że w systemie dostępna jest biblioteka języka C w standardowej
 wersji GNU 
\begin_inset CommandInset citation
LatexCommand cite
key "gnu-c-lib"

\end_inset

 .
 W celu skompilowania modułu graficznego, konieczne jest również udostępnienie
 standardowej biblioteki języka C++ GNU 
\begin_inset CommandInset citation
LatexCommand cite
key "gnu-cpp-lib"

\end_inset

 oraz biblioteki Qt w wersji 5 
\begin_inset CommandInset citation
LatexCommand cite
key "qtman"

\end_inset

 .
 W trakcie działania, program wykorzystuje elementy języka C, których implementa
cja zależna jest od systemu - w przypadku środowiska Linux, konieczne moduły
 wspierane są od jądra w wersji 2.6.13 i znajdują się w standardowej bibliotece
 języka C.
\end_layout

\begin_layout Standard
kompilatory
\end_layout

\begin_layout Standard
W celu uproszczenia procesu budowana i instalacji, posłużono się oprogramowaniem
 cmake 
\begin_inset CommandInset citation
LatexCommand cite
key "cmake-page"

\end_inset

 - program ten umożliwia przeprowadzenie procesu budowania i rozwiązywanie
 zależności niezależnie od systemu operacyjnego użytkownika.
 Przeprowadzono testy z wersjami 2.6 oraz 3.3 i potwierdzono poprawność budowania
 programu.
 
\end_layout

\begin_layout Standard
Oprogramowanie to umożliwia również możliwość przeprowadzenia procesu budowania
 przy użyciu kompilatora zdefiniowanego przez użytkownika.
 W trakcie projektowania programów, duży nacisk położono na ich poprawność
 implementacji - pełną zgodność ze standardem języka.
 Dzięki temu, dowolny kompilator języka C implementujący standard C99 powinien
 umożliwić zbudowanie modułów 
\begin_inset CommandInset citation
LatexCommand cite
key "cstandard"

\end_inset

 .
 Moduł graficzny może zostać zbudowany przy użyciu dowolnego kompilatora
 języka C++ wspierającego standard C++11 
\begin_inset CommandInset citation
LatexCommand cite
key "cpp-standard"

\end_inset

 .
 Moduł zgodny jest również ze standardem C++14, nie wykorzystuje przy tym
 jednak funkcji języka udostępnionych w tej normie.
 Poprawność przebiegu procesu budowania potwierdzono w trakcie testów z
 dwoma kompilatorami - clang w wersji 3.7.0 oraz gcc w wersjach 4.8.1 oraz 5.2.0
 
\begin_inset CommandInset citation
LatexCommand cite
key "clang,gcc"

\end_inset

 .
 Oba kompilatory przeprowadziły proces budowania, nie wskazując przy tym
 na żadne problemy.
\end_layout

\begin_layout Section*
Instalacja
\end_layout

\begin_layout Standard
Proces budowania powinien zostać wykonany z poziomu katalogu, który nie
 znajduje się wewnątrz głównego katalogu projektu.
 Standardowym podejściem jest utworzenie katalogu 
\shape italic
build 
\shape default
i przejście do niego.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

[user@pc projekt]$ mkdir build && cd build
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Następnie, wykorzystując oprogramowanie 
\shape italic
cmake, 
\shape default
należy wygenerować zbiór plików wykorzystywanych w procesie budowania.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

[user@pc build]$ cmake ..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Argumentem programu cmake jest ścieżka do głównego katalogu budowanego projektu.
 W przypadku budowy w niestandardowej lokacji, konieczne jest podanie poprawnej
 ścieżki do katalogu zawierającego kod programu i plik 
\shape italic
CMakeLists.txt
\shape default
.
\end_layout

\begin_layout Standard
Domyślnie nie zostaną wygenerowane pliki potrzebne do zbudowania modułu
 graficznego.
 Można to zmienić, dodając do powyższego polecenia flagę:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

[user@pc build]$ cmake ..
 -DCOMPILE_GUI=ON
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Proces ten powinien zakończyć się powodzeniem, jeśli spełnione zostały wszystkie
 wymagania odnośnie środowiska, w którym budowany jest projekt.
 Kolejnym krokiem jest wygenerowanie plików binarnych dla każdego modułu
 poprzez polecenie:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

[user@pc build]$ make
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ten proces również powinien zakończyć działanie nie wskazując żadnego błędu,
 jeśli spełnione zostały wymagania.
 
\end_layout

\begin_layout Standard
Pliki modułów znajdują się wewnątrz podkatalogu 
\shape italic
/bin
\shape default
 obecnej ścieżki.
 Możliwe jest również zainstalowanie uzyskanych w ostatnim kroku plików
 w systemie, wykorzystując do tego poniższe polecenie.
 Należy jednocześnie pamiętać o konieczności posiadania uprawnień administratora
, by komenda się powiodła.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=bash"
inline false
status open

\begin_layout Plain Layout

[user@pc build]# make install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
W przypadku powodzenia akcji, moduły i ich podręczniki zostały zainstalowane
 i powinny być dostępne z poziomu terminala.
 W dalszej części pracy przyjęto założenie, że użytkownik zdecydował się
 na instalację, tak by maksymalnie uprościć prezentowane polecenia.
\end_layout

\begin_layout Chapter
Podział na moduły
\end_layout

\begin_layout Chapter
Użytkowanie programu
\end_layout

\begin_layout Section
Metody uruchamiania
\end_layout

\begin_layout Section
Obsługiwane parametry
\begin_inset CommandInset label
LatexCommand label
name "sub:flags"

\end_inset


\end_layout

\begin_layout Section
Budowanie łańcucha modułów
\end_layout

\begin_layout Section
Przykładowe aplikacje
\end_layout

\begin_layout Section*
Podsumowanie
\end_layout

\begin_layout Standard
// manuale
\end_layout

\begin_layout Chapter
Analiza poprawności pracy programu
\end_layout

\begin_layout Section
Poprawność algorytmu
\end_layout

\begin_layout Section
Wydajność pracy programu
\begin_inset CommandInset label
LatexCommand label
name "sub:efficiency"

\end_inset


\end_layout

\begin_layout Section
Stabilność pracy programu
\begin_inset CommandInset label
LatexCommand label
name "sub:stability"

\end_inset


\end_layout

\begin_layout Chapter
Podsumowanie
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliografia"
options "bibtotoc,IEEEtranM"

\end_inset


\end_layout

\end_body
\end_document
